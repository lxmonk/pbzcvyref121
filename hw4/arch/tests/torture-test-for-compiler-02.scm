;;; torture-test-for-compiler-02.scm
;;; Testing the primitives and some of the support procedures (e.g., equal?)
;;;
;;; Programmer: Mayer Goldberg, 2010

(and
 (boolean? #t)
 (boolean? #f)
 (not (boolean? 1234))
 (not (boolean? 'a))
 (symbol? 'b)
 (procedure? procedure?)
 (eq? (car '(a b c)) 'a)
 (= (car (cons 1 2)) 1)
 (integer? 1234)
 (char? #\a)
 (null? '())
 (string? "abc")
 (symbol? 'lambda)
 (vector? '#(1 2 3))
 (not (vector? 1234))
 (not (string? '#(a b c)))
 (not (string? 1234))
 (= 3 (vector-length '#(a #t ())))
 (pair? '(a . b))
 (not (pair? '()))
 (zero? 0)
 (not (zero? 234))
 (= 97 (char->integer (string-ref "abc" 0)))
 (let ((n 10000))
   (= n (string-length (make-string n))))
 (let ((n 10000))
   (= n (vector-length (make-vector n))))
 (let* ((v (make-vector 3))
	(vs! (lambda (i x) (vector-set! v i x))))
   (vs! 0 'a)
   (vs! 1 234)
   (vs! 2 #\P)
   (equal? v '#(a 234 #\P)))
 (let ((p (cons 'a 'b)))
   (set-car! p 'just)
   (set-cdr! p 'fine)
   (equal? p '(just . fine)))
 (let ((v '#(a b c)))
   (eq? 'c (vector-ref v 2)))
 (= 65 (char->integer #\A))
 (let ((string (make-string 2)))
   (string-set! string 0 (integer->char 97))
   (string-set! string 1 (integer->char 98))
   (eq? 'ab (string->symbol string)))
 (let ((string (symbol->string 'abc)))
   (and (char=? (string-ref string 0) #\a)
	(char=? (string-ref string 1) #\b)
	(char=? (string-ref string 2) #\c)
	(= 3 (string-length string))))
 (= 3 (remainder 7 4))
 (= 6 (* 1 2 3))
 (= 1 (*))
 (= 234 (* 234))
 (= 6 (+ 1 2 3))
 (zero? (+))
 (= 234 (+ 234))
 (= 1 (- 6 3 2))
 (< 1 2 3 4 5)
 (> 5 4 3 2 1)
 (equal? '(2 . 3) (apply cons '(2 3)))
 )
